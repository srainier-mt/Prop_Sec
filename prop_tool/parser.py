from __future__ import annotations

import io
import re
from pathlib import Path
from typing import BinaryIO, Iterable, Sequence

import pandas as pd
from PyPDF2 import PdfReader

_COLUMNS: Sequence[str] = (
    "rpm",
    "mph",
    "advance_ratio",
    "prop_efficiency",
    "ct",
    "cp",
    "power_hp",
    "torque_in_lbf",
    "thrust_lbf",
    "power_w",
    "torque_nm",
    "thrust_n",
    "thrust_per_w",
    "mach",
    "reynolds",
    "fom",
)


def _read_text_from_pdf(data: bytes | str | Path | BinaryIO) -> str:
    if isinstance(data, (str, Path)):
        reader = PdfReader(str(data))
    else:
        if isinstance(data, (bytes, bytearray)):
            raw = bytes(data)
        else:
            raw = data.read()
            if hasattr(data, "seek"):
                data.seek(0)
        buffer = io.BytesIO(raw)
        reader = PdfReader(buffer)
    return "\n".join(page.extract_text() for page in reader.pages)


def _read_text_from_plain(data: bytes | str | Path | BinaryIO) -> str:
    if isinstance(data, (str, Path)):
        return Path(data).read_text(encoding="utf-8")
    if isinstance(data, (bytes, bytearray)):
        return data.decode("utf-8", errors="replace")
    raw = data.read()
    if hasattr(data, "seek"):
        data.seek(0)
    return raw.decode("utf-8", errors="replace")


def _iter_numeric_lines(text: str) -> Iterable[str]:
    for line in text.splitlines():
        stripped = line.strip()
        if not stripped:
            continue
        if re.match(r"^[-0-9]", stripped):
            yield stripped
        elif stripped.startswith("PROP RPM"):
            yield stripped


def load_apc_data(source: str | Path | BinaryIO | bytes) -> pd.DataFrame:
    """Parse an APC .DAT or PDF file into a tidy :class:`~pandas.DataFrame`.

    Parameters
    ----------
    source:
        Path or file-like object that points to an APC performance file. Both
        the plain-text ``.dat`` exports and the PDF reports generated by APC's
        tools are supported.
    """

    name = getattr(source, "name", "").lower()
    if isinstance(source, (str, Path)):
        suffix = Path(source).suffix.lower()
    elif name:
        suffix = Path(name).suffix.lower()
    else:
        suffix = ""

    if suffix == ".pdf":
        text = _read_text_from_pdf(source)
    else:
        text = _read_text_from_plain(source)

    rows: list[list[float]] = []
    current_rpm: int | None = None
    pending: list[str] = []

    rpm_pattern = re.compile(r"PROP RPM =\s+(\d+)")

    for line in _iter_numeric_lines(text):
        match = rpm_pattern.search(line)
        if match:
            current_rpm = int(match.group(1))
            pending.clear()
            continue

        if current_rpm is None:
            continue

        parts = line.split()
        cleaned: list[str] = []
        for part in parts:
            if part.endswith(".") and part[:-1].replace(".", "", 1).isdigit():
                cleaned.append(part[:-1])
            else:
                cleaned.append(part)
        pending.extend(cleaned)

        if len(pending) == len(_COLUMNS) - 1:
            numeric_row = [float(current_rpm)]
            numeric_row.extend(float(value) for value in pending)
            rows.append(numeric_row)
            pending.clear()

    df = pd.DataFrame(rows, columns=_COLUMNS)
    return df
